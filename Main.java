/* autogenerated by Processing revision 1292 on 2023-06-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import g4p_controls.*;
import javax.swing.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Main extends PApplet {


float boxSize=8;
ArrayList<Gate> gate=new ArrayList<Gate>();
ArrayList<Wire> wires = new ArrayList<Wire>();
Connection inConnection;
Connection outConnection;

public void setup()
{
  /* size commented out by preprocessor */;
  surface.setResizable(true);
  surface.setTitle("DIGITAL LOGIC DESIGN SIMULATOR(DEVELOPER: MSS)");
  PFont font = createFont("Times New Roman", 20);
  int style = java.awt.Font.PLAIN;

  GButton andbutton = new GButton(this, 10, 120, 270, 30, "AND GATE ");
  andbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  andbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  andbutton.addEventHandler(this, "andbutton");

  GButton orbutton = new GButton(this, 10, 160, 270, 30, "OR GATE ");
  orbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  orbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  orbutton.addEventHandler(this, "orbutton");

  GButton notbutton = new GButton(this, 10, 200, 270, 30, "NOT GATE ");
  notbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  notbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  notbutton.addEventHandler(this, "notbutton");

  GButton nandbutton = new GButton(this, 10, 240, 270, 30, "NAND GATE ");
  nandbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  nandbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  nandbutton.addEventHandler(this, "nandbutton");

  GButton norbutton = new GButton(this, 10, 280, 270, 30, "NOR GATE");
  norbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  norbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  norbutton.addEventHandler(this, "norbutton");

  GButton probbutton = new GButton(this, 10, 440, 270, 30, "LOGIC PROB");
  probbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  probbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  probbutton.addEventHandler(this, "probbutton");

  GButton togglebutton = new GButton(this, 10, 400, 270, 30, "LOGIC TOGGLE");
  togglebutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  togglebutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  togglebutton.addEventHandler(this, "togglebutton");

  GButton mulbutton = new GButton(this, 10, 560, 270, 30, "2-1 MULTIPLEXER");
  mulbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  mulbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  mulbutton.addEventHandler(this, "mulbutton");

  GButton mul4button = new GButton(this, 10, 600, 270, 30, "4 TO 1 MULTIPLEXER");
  mul4button.setLocalColorScheme(GCScheme.RED_SCHEME);
  mul4button.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  mul4button.addEventHandler(this, "mul4button");

  GButton halfadderbutton = new GButton(this, 10, 520, 270, 30, "HALF ADDER");
  halfadderbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  halfadderbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  halfadderbutton.addEventHandler(this, "halfadderbutton");

  GButton xorbutton = new GButton(this, 10, 360, 270, 30, "XOR");
  xorbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  xorbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  xorbutton.addEventHandler(this, "xorbutton");

  GButton xnorbutton = new GButton(this, 10, 320, 270, 30, "XNOR");
  xnorbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  xnorbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  xnorbutton.addEventHandler(this, "xnorbutton");

  GButton displaybutton = new GButton(this, 10, 640, 270, 30, "SEVEN SEGMENT DISPLAY");
  displaybutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  displaybutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  displaybutton.addEventHandler(this, "displaybutton");

  GButton fulladderbutton= new GButton(this, 10, 680, 270, 30, "FULL ADDER");
  fulladderbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  fulladderbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  fulladderbutton.addEventHandler(this, "fulladderbutton");

  GButton decoder1button= new GButton(this, 10, 720, 270, 30, "DECODER (2 TO 4 LINES)");
  decoder1button.setLocalColorScheme(GCScheme.RED_SCHEME);
  decoder1button.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  decoder1button.addEventHandler(this, "decoder1button");

  GButton halfsubtractorbutton= new GButton(this, 10, 760, 270, 30, "HALF SUBTRACTOR ");
  halfsubtractorbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  halfsubtractorbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  halfsubtractorbutton.addEventHandler(this, "halfsubtractorbutton");

  GButton jkbutton= new GButton(this, 10, 840, 270, 30, "JK FLIP FLOP");
  jkbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  jkbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  jkbutton.addEventHandler(this, "jkbutton");

  GButton srbutton= new GButton(this, 10, 880, 270, 30, "SR FLIP FLOP");
  srbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  srbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  srbutton.addEventHandler(this, "srbutton");

  GButton dbutton= new GButton(this, 10, 920, 270, 30, "D FLIP FLOP");
  dbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  dbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  dbutton.addEventHandler(this, "dbutton");

  GButton tbutton= new GButton(this, 10, 960, 270, 30, "T FLIP FLOP");
  tbutton.setLocalColorScheme(GCScheme.RED_SCHEME);
  tbutton.setFont(new java.awt.Font(font.getName(), style, font.getSize()));
  tbutton.addEventHandler(this, "tbutton");
}

public void draw() {
  background(0);
  fill(0xFFF53434);
  rect(50, 2, 82, 70);
  fill(0xFF403738);
  rect(50, 28, 82, 20);
  textSize(15);
  fill(0xFFDFE2EA);
  text("HIGH", 79, 40);
  fill(0xFF0FA036);
  rect(150, 2, 82, 70);
  fill(0xFF403738);
  rect(150, 28, 82, 20);  //
  textSize(15);
  fill(0xFFDFE2EA);
  text("LOW", 180, 40);
  fill(0xFF403738);
  rect(10, 80, 270, 30);
  textSize(20);
  fill(0xFFDFE2EA);
  text("LOGIC GATES", 85, 100);
  fill(0xFF403738);
  rect(10, 480, 270, 30);
  textSize(20);
  fill(0xFFDFE2EA);
  text("COMBINATIONAL CIRCUITS", 35, 500);
  fill(0xFF403738);
  rect(10, 800, 270, 30);
  textSize(20);
  fill(0xFFDFE2EA);
  text("SEQUENTIAL CIRCUITS", 55, 820);
  for (int i=300; i<=width; i+=boxSize) {
    stroke(0xFF4B4D46);
    strokeWeight(0.5f);
    line(i, 0, i, height);
  }
  for (int i=0; i<=height; i+=boxSize) {
    stroke(0xFF4B4D46);
    strokeWeight(0.5f);
    line(300, i, width, i);
  }
  for (int i=0; i<gate.size(); i++)  gate.get(i).show();
  for (Wire w : wires) w.show();

  if (inConnection != null)
  {
    stroke(0xFFFFFFFF);
    line(inConnection.x + inConnection.type*connectionWidth, inConnection.y, mouseX, mouseY);
  }
}
public void mousePressed() {
  for (int i=gate.size()-1; i>=0; i--) {
    gate.get(i).select=false;
    if (gate.get(i).drag()) break;
  }
  for (int i=wires.size()-1; i>=0; i--)
  {
    wires.get(i).selectWire();
  }
  for (Gate g : gate) for (Connection c : g.connections) c.checkConnection();
  if (inConnection != null && outConnection != null )  makeConnection();
}
public void mouseClicked() {
  for (int i=0; i<gate.size(); i++) {
    gate.get(i).switchButton();
  }
}

public void mouseReleased() {
  for (int i=0; i<gate.size(); i++) {
    gate.get(i).release();
  }
}
public void keyPressed() {
  if (key=='d') {
    for (int i=0; i<gate.size(); i++)gate.get(i).delete();
    for (int i=0; i<wires.size(); i++) wires.get(i).delete();
  }
  if (key=='q') {
    gate.clear();
    wires.clear();
  }
}

public void andbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new And(width/2, height/2, 100, 100));
}
public void orbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new Or(width/2, height/2, 100, 100));
}
public void notbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new Not(width/2, height/2, 100, 100));
}
public void nandbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new Nand(width/2, height/2, 100, 100));
}
public void norbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)  gate.add(new Nor(width/2, height/2, 100, 100));
}
public void probbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)  gate.add(new Prob(width/2, height/2, 50, 50));
}
public void togglebutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)  gate.add(new Toggle(width/2, height/2, 50, 50));
}
public void mulbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)    gate.add(new Multiplexer2(width/2, height/2, 100, 200));
}
public void mul4button(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)    gate.add(new Multiplexer4(width/2, height/2, 100, 200));
}
public void halfadderbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)    gate.add(new HalfAdder(width/2, height/2, 200, 100));
}
public void xorbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)    gate.add(new Xor(width/2, height/2, 100, 100));
}
public void xnorbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)    gate.add(new Xnor(width/2, height/2, 100, 100));
}
public void displaybutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)    gate.add(new SevenSegmentDisplay(width/2, height/2, 100, 100));
}
public void fulladderbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)     gate.add(new FullAdder(width/2, height/2, 100, 100));
}
public void decoder1button(GButton source, GEvent event) {
  if (event==GEvent.CLICKED)  gate.add(new Decoder1(width/2, height/2, 100, 200));
}
public void halfsubtractorbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new HalfSubtractor(width/2, height/2, 200, 100));
}
public void jkbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new jkFlipFlop(width/2, height/2, 100, 200));
}
public void srbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new srFlipFlop(width/2, height/2, 100, 200));
}
public void dbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new dFlipFlop(width/2, height/2, 100, 200));
}
public void tbutton(GButton source, GEvent event) {
  if (event==GEvent.CLICKED) gate.add(new tFlipFlop(width/2, height/2, 100, 200));
}

public void makeConnection()
{
  Wire newWire = new Wire(inConnection, outConnection);
  wires.add(newWire);
  inConnection = null;
  outConnection=null;
}
float connectionWidth = 30;

class Connection
{
  float x;
  float y;
  float dx;
  float dy;
  boolean value;
  int type;
  boolean connected;
  Gate parent;
  Wire wire;
  boolean alreadyConnected;
  Connection(Gate parent, float dx, float dy, int type)
  {
    this.parent = parent;
    this.dx = dx;
    this.dy = dy;
    this.x = parent.x+dx;
    this.y = parent.y+dy;
    this.type = type;
  }

  public void show()
  {
    this.x = parent.x+dx;
    this.y = parent.y+dy;
    if (!connected) stroke(255);
    else stroke(value ? 0xFFF53434: 0xFF0FA036);
    if (isHover()) stroke(0xFFFFFF00);
    line(x, y, x+(type*connectionWidth), y);
  }

  public boolean isHover()
  {
    float threshold = 5;
    if (type == 1) return (mouseX >= x && mouseX <= x+connectionWidth && mouseY >= y-threshold && mouseY <= y+threshold);
    if (type == -1) return (mouseX <= x && mouseX >= x-connectionWidth && mouseY >= y-threshold && mouseY <= y+threshold);
    return false;
  }

  public void checkConnection()
  {
    if (isHover())
    {
      if (inConnection == null &&  canGiveInput())
      {
        inConnection = this ;
        alreadyConnected=true;
      } else if ( !alreadyConnected && inConnection!=null && !canGiveInput()) {
        outConnection = this;
        alreadyConnected=true;
      }
    }
  }
  public boolean canGiveInput() {
    if (type==-1) return false;
    return true;
  }
}
class FullAdder extends Gate {
  FullAdder(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, 0, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, -Height/4, 1));
    connections.add(new Connection(this, Width, Height/4, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawfullAdder(x, y, Width, Height);
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void  drawfullAdder(float x, float  y, float Width, float  Height) {
    stroke(150);
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(10);
    text("I", x+2, y-Height/4);
    text("I", x+2, y);
    text("C", x+Width-20, y+Height/4);
    text("SUM", x+Width-20, y-Height/4);
    text("CARRY", x+Width-20, y+Height/4);
    text("FULLADDER", x+Width/2-10, y);
  }
  public boolean evaluate() {
    getInputs();
    boolean sum1= xor(connections.get(0).value, connections.get(1).value);
    connections.get(3).value=xor(connections.get(2).value, sum1);
    boolean c1=connections.get(0).value && connections.get(1).value;
    boolean c2=connections.get(2).value && sum1;
    connections.get(4).value=c1||c2;
    return true;
  }
  private boolean xor(boolean n1, boolean n2) {
    return( (n1&!n2) || (n2&!n1));
  }
}
class HalfSubtractor extends Gate {
  HalfSubtractor(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, -Height/4, 1));
    connections.add(new Connection(this, Width, +Height/4, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawSubtractor();
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawSubtractor() {
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(20);
    text("DIFF", x+Width-40, y-Height/4);
    text("CARRY", x+Width-60, y+Height/4);
    fill(0xFF0F0204);
    text("HALF SUB", (x+x+Width-90)/2, y);
  }
  public boolean evaluate() {
    connections.get(2).value=xor(connections.get(0).value, connections.get(1).value);
    connections.get(3).value=!connections.get(0).value && connections.get(1).value;
    return true;
  }
  private boolean xor(boolean n1, boolean n2) {
    return( (n1&!n2) || (n2&!n1));
  }
}
class Multiplexer2 extends Gate {
  Multiplexer2(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, 0, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, 0, 1));
  }
  public void show() {
    if (picked||select ) fill(255);
    else fill(150);
    
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    drawMultiplexer(x, y, Width, Height);
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawMultiplexer(float  x, float  y, float Width, float  Height) {
    stroke(150);
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(25);
    text("S", x+2, y-Height/4);
    text("I", x+2, y);
    text("I", x+2, y+Height/4);
    text("O", x+Width-20, y);
    textSize(10);
    text("MUX", x+Width/2, y);
  }
  public boolean evaluate() {
    getInputs();
    connections.get(3).value=connections.get(1).value&&(!connections.get(0).value)||connections.get(2).value&&(connections.get(0).value);
    return connections.get(3).value;
  }
}
class Multiplexer4 extends Gate {
  Multiplexer4(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/2, -1));
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, 0, -1));
    connections.add(new Connection(this, 0, Height/8, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, 0, Height/2, -1));
    connections.add(new Connection(this, Width, 0, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    drawMultiplexer4(x, y, Width, Height);
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawMultiplexer4(float  x, float  y, float Width, float  Height) {
    stroke(150);
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(15);
    text("S", x+2, y-Height/2+10);
    text("S", x+2, y-Height/4);
    text("I", x+2, y);
    text("I", x+2, y+Height/8);
    text("I", x+2, y+Height/4);
    text("I", x+2, y+Height/2);


    textSize(10);
    text("MUX", x+Width/2, y);
  }
  public boolean evaluate() {
    getInputs();
    connections.get(6).value=(!connections.get(0).value&& !connections.get(1).value && connections.get(2).value)||(!connections.get(0).value&& connections.get(1).value && connections.get(3).value)||(connections.get(0).value&& !connections.get(1).value && connections.get(4).value)||(connections.get(0).value&&connections.get(1).value && connections.get(5).value);
    return connections.get(6).value;
  }
}
class Prob extends Gate {
  Toggle t1;
  Toggle t2;
  
  boolean output;
  Prob(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    output=false;
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, Height/2, -1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    evaluate();
    rect(x, y, Width, Height);
   if (output) fill(0xFFF53434);
    else fill( 0xFF0FA036);
    rect(x + 10, y + 10, Width - 20, Height - 20);
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  public boolean evaluate() {
    getInputs();
    if (connections.get(0).value) output=true;
    else output=false;
    return connections.get(0).value;
  }
}
class SevenSegmentDisplay extends Gate {
  boolean A, B, C, D, E, F, G;
  SevenSegmentDisplay(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, -10, -Height/2+40, -1));
    connections.add(new Connection(this, -10, -Height/4+40, -1));
    connections.add(new Connection(this, -10, Height/4+40, -1));
    connections.add(new Connection(this, -10, Height/2+40, -1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawDisplay(x, y, Width, Height/2);
    evaluate();
    strokeWeight(3);
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawDisplay(float x, float  y, float Width, float  Height) {
    fill(A? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x, y-Height/2, Width, Height/4);

    fill(F? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x-10, y-Height/2+10, 10, Width/2);
    fill(E? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x-10, y-Height/2+10+Width/2, 10, Width/2);

    fill(D? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x, y-Height/2+10+Width, Width, 10);

    fill(B? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x+Width, y-Height/2+10, 10, Width/2);

    fill(C? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x+Width, y-Height/2+10+Width/2, 10, Width/2);

    fill(G? 0xFF00FF00 : 0xFFFBFFFA);
    rect(x, y+Height/2, Width, Height/4);
  }
  public boolean evaluate() {
    getInputs();
    boolean a=connections.get(0).value;
    boolean b=connections.get(1).value;
    boolean c=connections.get(2).value;
    boolean d=connections.get(3).value;
    A=(!a&&c) || (!a&&b&&d)|| (!b&&!c&&!d)|| (a&&!b&&!c);
    B=(!a&&!b) ||(!a&&!c&&!d) || (!a&&c&&d) ||(a&&!b&&!c);
    C= (!a&&b)||(!a&&d )||(!b&&!c&&!d)||(a&&!b&&!c);
    D=(!a&&c&&!d)||(!a&&!b&&c) ||(!b&&!c&&!d)||(a&&!b&&!c)||(!a&&b&&!c&&d);
    E=(!a&&c&&!d)||(!b&&!c&&!d);
    F=(!a&&b&&!c)||(!a&&!c&&!d)||(!a&&b&&d)||(a&&!b&&!c);
    G=(!a&&c&&!d)||(!a&&!b&&c)||(!a&&b&&!c)||(a&&!b&&!c );
    return true;
  }
}
class  Toggle extends Gate {
  boolean connected;
  boolean Switch;
  Toggle(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    this.Switch=true;
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, Width, Height/2, +1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    evaluate();
    rect(x, y, Width, Height);
    if (Switch) fill(0xFFF53434);
    else fill( 0xFF0FA036);
    rect(x + 10, y + 10, Width - 20, Height - 20);
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);

    if (isHoverSwitch()) {
      fill(0xFF1C47C4);
    }
  }
  public void changeButton() {
    Switch=!Switch;
  }
  public void switchButton() {
    if (isHoverSwitch())  Switch=!Switch;
  }

  public boolean evaluate() {
    connections.get(0).value=Switch;
    return  connections.get(0).value;
  }
  public boolean isHoverSwitch() {
    return(mouseX>=x + 10 &&mouseX<=x + 10+Width - 20&& mouseY>=y+10 &&mouseY<=y+10+Height-20);
  }
}
class Wire
{
  boolean select;
  Connection in;
  Connection out;

  Wire (Connection in, Connection out)
  {

    this.in = in;
    this.out = out;
    in.wire = this;
    out.wire = this;
  }

  public void show()
  {
    float inX = in.x + in.type*connectionWidth;
    float outX = out.x + out.type*connectionWidth;
    stroke(0xFF1CC0C4);
    if (isHover()) stroke(0xFF93A00F);
    if (select) stroke(255);
    line(outX, out.y, inX, in.y);
    out.value=in.value;
    in.connected=true;
    out.connected=true;
  }
  public void selectWire() {
    if (isHover())
    
    {
      for (int i=0; i<wires.size(); i++) wires.get(i).select=false;
      for (int i=0; i<gate.size(); i++) gate.get(i).select=false;
      wires.remove(this);
      wires.add(wires.size(), this);
      select=true;
    }
  }
  public void delete() {
    if (select)
    {
      wires.remove(this);
      in.alreadyConnected=false;
      out.alreadyConnected=false;
    }
  }
  public boolean isHover() {
    return (mouseX<=out.x + out.type*connectionWidth && mouseX>=in.x + in.type*connectionWidth && mouseY<=out.y  && mouseY>=in.y);//|| mouseY<=out.y || mouseX>=  in.x + in.type*connectionWidth+out.x + out.type*connectionWidth ||mouseY>=in.y+out.y
  }

}
class Xnor extends Gate {
  Xnor(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections=new ArrayList<Connection>();
    connections.add(new Connection(this, 8, -Height/4, -1));
    connections.add(new Connection(this, 8, +Height/4, -1));
    connections.add(new Connection(this, 29+Width, 0, +1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawXnor(x, y, Width, Height/2);
    strokeWeight(3);
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawXnor(float  x, float  y, float Width, float  Height) {
    stroke(150);
    beginShape();
    for (float i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      vertex(x+Width/2+(Width-Width/3)*cos(i), y+Height*sin(i));
    }
    for (float i=radians(90); i>=radians(-90); i-=radians(0.1f)) {
      vertex(x+Width/3*cos(i), y+Height*sin(i));
    }
    endShape();
    ellipse(x+Width/2+Width-Width/3+6, y, Width/6, Width/6);
    for (float  i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      point(x+Width/3*cos(i)-20, y+Height*sin(i));
    }
  }

  public boolean evaluate() {
    getInputs();

    connections.get(2).value = !(connections.get(0).value & (!connections.get(1).value)||connections.get(1).value & (!connections.get(0).value));
    return connections.get(2).value;
  }
}
class Xor extends Gate {
  Xor(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections=new ArrayList<Connection>();
    connections.add(new Connection(this, 8, -Height/4, -1));
    connections.add(new Connection(this, 8, +Height/4, -1));
    connections.add(new Connection(this, 22+Width, 0, +1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawXor(x, y, Width, Height/2);
    strokeWeight(3);
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawXor(float  x, float  y, float Width, float  Height) {
    stroke(150);
    beginShape();
    for (float i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      vertex(x+Width/2+(Width-Width/3)*cos(i), y+Height*sin(i));
    }
    for (float i=radians(90); i>=radians(-90); i-=radians(0.1f)) {
      vertex(x+Width/3*cos(i), y+Height*sin(i));
    }
    for (float  i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      point(x+Width/3*cos(i)-20, y+Height*sin(i));
    }
    endShape();
  }


  public boolean evaluate() {
    getInputs();

    connections.get(2).value = connections.get(0).value & (!connections.get(1).value)||connections.get(1).value & (!connections.get(0).value);
    return connections.get(2).value;
  }
}
class And extends Gate {
  And(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, 0, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawAnd(x, y, Width, Height/2);
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawAnd(float  x, float  y, float Width, float  Height) {
    stroke(150);
    beginShape();

    for (float i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      vertex(x+Width*cos(i), y+ Height*sin(i));
    }
    endShape();
  }

  public boolean evaluate() {
    getInputs();
    connections.get(2).value = connections.get(0).value && connections.get(1).value;
    return connections.get(2).value;
  }
}
class dFlipFlop extends sequentialCircuits {
  boolean memory;
  dFlipFlop(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height, "C", "D", "Q", "Q'", "D");
  }
  public boolean evaluate() {
    if (!connections.get(0).value) {
      connections.get(2).value=memory;
      connections.get(3).value=!memory;
      return true;
    } else {
      connections.get(2).value=connections.get(1).value;
      connections.get(3).value=!connections.get(1).value;
      memory= connections.get(1).value;
      return connections.get(2).value;
    }
  }
}
class Decoder1 extends Gate {
  Decoder1(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, 0, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, -Height/2, 1));
    connections.add(new Connection(this, Width, -Height/4, 1));
    connections.add(new Connection(this, Width, +Height/4, 1));
    connections.add(new Connection(this, Width, +Height/2, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);

    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    drawDecoder(x, y, Width, Height);
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawDecoder(float  x, float  y, float Width, float  Height) {
    stroke(150);
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(25);
    text("Enable", x+2, y-Height/4);
    text("I0", x+2, y);
    text("I1", x+2, y+Height/4);
    textSize(10);
    text("DEOCODER", x+Width/2, y);
  }
  public boolean evaluate() {
    getInputs();
    boolean e,a,b;
    e=connections.get(0).value;
    a=connections.get(1).value;
    b=connections.get(2).value;
    connections.get(3).value=!(!a&&!b&&!e);
    connections.get(4).value=!(!a&&b&&!e);
    connections.get(5).value=!(a&&!b&&!e);
    connections.get(6).value= !(a&&b&&!e);
    return connections.get(3).value;
  }
}
abstract class Gate {
  float x;
  float y;
  float Width;
  float Height;
  boolean picked;
  boolean select;

  ArrayList<Connection> connections;

  Gate(float x, float  y, float Width, float  Height) {
    this.x=x;
    this.y=y;
    this.Height=Height;
    this.Width=Width;
    this.picked=false;
  }
  public boolean isHover() {
    return (mouseX >= x && mouseX <= Width+x && mouseY >= y-Height/2 && mouseY <= y+Height/2);
  }
  public boolean drag()
  {
    if (isHover())
    {
      for (int i=0; i<gate.size(); i++) gate.get(i).select=false;
      for (int i=0; i<wires.size(); i++) wires.get(i).select=false;
      gate.remove(this);
      gate.add(gate.size(), this);
      picked = true;
      select=true;
    }
    return picked;
  }
  public void release()
  {
    if (isHover())
    {
      picked = false;
      roundOff();
    }
  }
  public void delete() {
    if (select)
      gate.remove(this);
  }
  public void roundOff() {
    int X= PApplet.parseInt(x/boxSize);
    int Y= PApplet.parseInt(y/boxSize);
    x=X*boxSize;
    y=Y*boxSize;
  }
  public void getInputs()
  {
    for (Connection c : connections)
    {
      if (c.type == -1)c.value = c.value;
    }
  }
  public void switchButton() {
  }

  public abstract void show();
  public abstract boolean evaluate();
}
class HalfAdder extends Gate {
  HalfAdder(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, -Height/4, 1));
    connections.add(new Connection(this, Width, +Height/4, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawAdder();
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawAdder() {
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(20);
    text("SUM", x+Width-40, y-Height/4);
    text("CARRY", x+Width-60, y+Height/4);
    fill(0xFF0F0204);
    text("HALF ADDER", (x+x+Width-90)/2, y);
  }
  public boolean evaluate() {
    connections.get(2).value=xor(connections.get(0).value, connections.get(1).value);
    connections.get(3).value=connections.get(0).value && connections.get(1).value;
    return true;
  }
  private boolean xor(boolean n1, boolean n2) {
    return( (n1&!n2) || (n2&!n1));
  }
}
class jkFlipFlop extends sequentialCircuits{
  boolean memory;
jkFlipFlop(float x, float  y, float Width, float  Height){
super(x, y, Width, Height,"J","K","Q","Q'","JK");
}
 public boolean evaluate(){
    
   if(connections.get(0).value &&connections.get(1).value){
    connections.get(2).value=!memory;
    connections.get(3).value=!connections.get(2).value;
     return true;
   }
   memory=connections.get(2).value;
  boolean temp= connections.get(2).value;
 connections.get(2).value=(connections.get(0).value&& !temp)||(!connections.get(1).value&& temp);
 connections.get(3).value=!temp;
 return connections.get(2).value;
 }
}
class Nand extends Gate {
  Nand(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width+15, 0, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawAnd(x, y, Width, Height/2);
    strokeWeight(3);
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawAnd(float  x, float  y, float Width, float  Height) {
    stroke(150);
    beginShape();

    for (float i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      vertex(x+Width*cos(i), y+ Height*sin(i));
    }
    endShape();
    ellipse(x+Width+5, y, Width/6, Width/6);
  }
  public boolean evaluate() {
    getInputs();

    connections.get(2).value = !(connections.get(0).value && connections.get(1).value);
    return connections.get(2).value;
  }

}
class Nor extends Gate {

  Nor(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 22, -Height/4, -1));
    connections.add(new Connection(this, 22, +Height/4, -1));
    connections.add(new Connection(this, Width+30, 0, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    drawOr(x, y, Width, Height/2);
    strokeWeight(3);
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawOr(float  x, float  y, float Width, float  Height) {
    stroke(150);
    beginShape();
    for (float i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      vertex(x+Width/2+(Width-Width/3)*cos(i), y+Height*sin(i));
    }
    for (float i=radians(90); i>=radians(-90); i-=radians(0.1f)) {
      vertex(x+Width/3*cos(i), y+Height*sin(i));
    }
    endShape();
    ellipse(x+Width/2+Width-Width/3+6, y, Width/6, Width/6);
  }
  public boolean evaluate() {
    getInputs();

    connections.get(2).value = !(connections.get(0).value || connections.get(1).value);
    return connections.get(2).value;
  }
}
class Not extends Gate {  //<>//
  Not(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, 0, -1));
    connections.add(new Connection(this, Width-45, 0, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
    drawNot(x, y, Width/2, Height/2);
  }
  private void drawNot(float  x, float  y, float Width, float  Height) {
    stroke(150);
    triangle(x, y-Height/2, x, y+Height/2, x+Width, y);
    ellipse(x+Width, y, Width/5, Width/5);
    strokeWeight(3);
  }
  public boolean evaluate() {
    getInputs();
    connections.get(1).value = !(connections.get(0).value);
    return connections.get(1).value;
  }
}
class Or extends Gate {
  Or(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height);
    connections=new ArrayList<Connection>();
    connections.add(new Connection(this, 22, -Height/4, -1));
    connections.add(new Connection(this, 22, +Height/4, -1));
    connections.add(new Connection(this, 22+Width, 0, +1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);
    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }

    drawOr(x, y, Width, Height/2);
    strokeWeight(3);
    evaluate();
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void drawOr(float  x, float  y, float Width, float  Height) {
    stroke(150);
    beginShape();
    for (float i=radians(-90); i<=radians(90); i+=radians(0.1f)) {
      vertex(x+Width/2+(Width-Width/3)*cos(i), y+Height*sin(i));
    }
    for (float i=radians(90); i>=radians(-90); i-=radians(0.1f)) {
      vertex(x+Width/3*cos(i), y+Height*sin(i));
    }
    endShape();
  }


  public boolean evaluate() {
    getInputs();

    connections.get(2).value = connections.get(0).value || connections.get(1).value;
    return connections.get(2).value;
  }
}
abstract class sequentialCircuits extends Gate {
  String n1, n2, n3, n4, name;
  sequentialCircuits(float x, float  y, float Width, float  Height, String n1, String n2, String n3, String n4, String name) {
    super(x, y, Width, Height);
    this.name=name;
    this.n1=n1;
    this.n2=n2;
    this.n3=n3;
    this.n4=n4;
    connections = new ArrayList<Connection>();
    connections.add(new Connection(this, 0, -Height/4, -1));
    connections.add(new Connection(this, 0, Height/4, -1));
    connections.add(new Connection(this, Width, -Height/4, 1));
    connections.add(new Connection(this, Width, Height/4, 1));
  }
  public void show() {
    if (picked||select) fill(255);
    else fill(150);

    if (picked)
    {
      x += mouseX-pmouseX;
      y += mouseY-pmouseY;
    }
    drawsequentialCircuits(x, y, Width, Height);
    evaluate();
    strokeWeight(3);
    for (Connection c : connections) c.show();
    strokeWeight(1);
  }
  private void  drawsequentialCircuits(float x, float  y, float Width, float  Height) {
    stroke(150);
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(25);
    text(n1, x+2, y-Height/4);
    text(n2, x+2, y+Height/4);
    text(n3, x+Width-20, y-Height/4);
    text(n4, x+Width-20, y+Height/4);
    text(name, x+Width/2-10, y);
  }
  private void  drawsequentialCircuits(float x, float  y, float Width, float  Height, String s2) {
    stroke(150);
    rect(x, y-Height/2, Width, Height);
    fill(0xFF0F0204);
    textSize(25);
    text("I", x+2, y);
    text("O", x+Width-20, y);
    text("MUX", x+Width/2, y);
  }
}

class srFlipFlop extends sequentialCircuits {
  srFlipFlop(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height, "S", "r", "Q", "Q'", "SR");
  }
  public boolean evaluate() {
    if (connections.get(0).value &&connections.get(1).value) {
      connections.get(2).value=false;
      connections.get(3).value=false;
      return true;
    }
    boolean temp= connections.get(2).value;
    connections.get(2).value=(connections.get(0).value)||(!connections.get(1).value&& temp);
    connections.get(3).value=!temp;
    return connections.get(2).value;
  }
}
class tFlipFlop extends sequentialCircuits {
  boolean memory;
  tFlipFlop(float x, float  y, float Width, float  Height) {
    super(x, y, Width, Height, "C", "T", "Q", "Q'", "T");
  }
  public boolean evaluate() {
    if (!connections.get(0).value) {
      connections.get(2).value=connections.get(1).value;
      connections.get(3).value=!connections.get(1).value;
      return true;
    } else {
      connections.get(2).value=!connections.get(1).value;
      connections.get(3).value=connections.get(1).value;
      memory= connections.get(1).value;
      return connections.get(2).value;
    }
  }
}


  public void settings() { size(1900, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
